name: Validate Curated Release Notes
on:
  pull_request:
    branches:
      - main
jobs:
  validate-schema:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Get changed files in PR
        id: changed-files
        run: |
          # Fetch the list of modified files in the PR
          changed_files=$(jq -r '.pull_request.files[] | select(.filename | startswith("addons/")) | .filename' <(gh pr view ${{ github.event.pull_request.number }} --json files))
          echo "Changed files: $changed_files"
          echo "::set-output name=files::$changed_files"

      - name: Validate JSON schema
        run: |
          error_count=0
          error_list=()  # Array to collect all errors
          allowed_labels=("kind/bug-fix" "N/A" "kind/feature" "kind/upgrade-consideration" "kind/breaking-change" "kind/api-change" "kind/deprecation" "impact/high" "impact/medium")

          for file in ${{ steps.changed-files.outputs.files }}; do
            if [[ "$file" == *curated-release-notes.json ]]; then
              echo "Validating $file"
              
              # Check if the JSON file contains required fields
              if ! jq -e '.addonName and .version and .releaseDate and .notes' "$file" > /dev/null; then
                error_message="Error: $file is missing one or more required fields (addonName, version, releaseDate, notes)."
                error_list+=("$error_message")
                error_count=$((error_count + 1))
              fi
              
              # Validate releaseDate using a regular expression for format YYYY-MM-DD
              release_date=$(jq -r '.releaseDate' "$file")
              if [[ ! "$release_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
                error_message="Error: Invalid date format in $file. Expected YYYY-MM-DD."
                error_list+=("$error_message")
                error_count=$((error_count + 1))
              fi
              
              # Further validation using the date command to ensure it's a real date
              if ! date -d "$release_date" +"%Y-%m-%d" > /dev/null 2>&1; then
                error_message="Error: Invalid date in $file. Expected a valid date in YYYY-MM-DD format."
                error_list+=("$error_message")
                error_count=$((error_count + 1))
              fi

              # Check if 'notes' contains both 'label' and 'text', and validate them
              notes_count=$(jq '.notes | length' "$file")
              for i in $(seq 0 $((notes_count-1))); do
                note_label=$(jq -r ".notes[$i].label[]" "$file")
                note_text=$(jq -r ".notes[$i].text" "$file")

                # Check if label or text is missing
                if [ -z "$note_label" ] || [ -z "$note_text" ]; then
                  error_message="Error: Note entry $i in $file has an empty 'label' or 'text' field."
                  error_list+=("$error_message")
                  error_count=$((error_count + 1))
                  continue
                fi

                # Validate that both 'kind' and 'impact' labels are present
                has_kind_label=false
                has_impact_label=false
                for label in $note_label; do
                  if [[ "$label" == kind/* ]]; then
                    has_kind_label=true
                  elif [[ "$label" == impact/* ]]; then
                    has_impact_label=true
                  fi
                done

                if [ "$has_kind_label" = false ] || [ "$has_impact_label" = false ]; then
                  error_message="Error: Note entry $i in $file is missing either 'kind' or 'impact' label. Both are required."
                  error_list+=("$error_message")
                  error_count=$((error_count + 1))
                fi

                # Check if each label is in the allowed list
                for label in $note_label; do
                  if [[ ! " ${allowed_labels[@]} " =~ " $label " ]]; then
                    error_message="Error: Invalid label '$label' in note entry $i of $file. Allowed labels are: ${allowed_labels[*]}."
                    error_list+=("$error_message")
                    error_count=$((error_count + 1))
                  fi
                done
              done
              echo "$file passed all validation checks."
            fi
          done

          # Final error summary
          if [ $error_count -gt 0 ]; then
            echo "Validation complete. Found $error_count errors:"
            for err in "${error_list[@]}"; do
              echo "$err"
            done
            exit 1
          else
            echo "All files passed validation checks."
          fi
